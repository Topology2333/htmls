---
title: 4-计导导论
author: Topology2333
date: '2022-12-06'
tags: computer science
---
# 这一篇转载 4
```

```
## 提纲
### 4.1  计算过程与算法的概念
### 4.2  算法的三种结构
### 4.3  算法的描述
### 4.4  算法的基本方法
### 4.5  自动机计算模型
### 4.6  穷举法
```

```

# 4.1    计算
## 一、计算  
计算机求解问题的本质是：计算  
```“计算”就是遵循一定的规则,  用刻板、机械的动作进行的过程 。  ```  
例：  
对输入行12+3进行计算，得出15。  
对一行汉字进行计算，得出英文。  
输入公理和规则，得出结论。（定理证明）  

## 二、计算过程  
	对复杂问题，直接写出能解决该问题的计算机程序是困难的，为此，人们在进行程序设计时分两步走：  
1）算法设计：```不使用程序设计语言，而使用一种较简单明了的表达方式（例如自然语言）设计出求解问题的步骤序列---算法。  ```  
2）程序编写：```根据设计好的算法，使用某种程序设计语言编写该算法的程序 。```
# 4.1    算法的概念
## 三、算法(Algorithm)的概念  
	算法：是解决问题的步骤序列（操作序列）。 
## 四、算法的特性  
```
是计算机可执行的操作；  
要在计算机能力集上进行算法设计；  
```
算法必须具备的五个特性：  
可执行性：```算法中的每一个步骤都是计算机可执行的（在计算机能力集范围内）； ```   
确定性：```算法中的每一个步骤，必须是明确定义的，不得有任何歧义性 ； ```   
有穷性：```算法必须在执行有穷步之后结束； ```    
有输入信息的说明：```加工对象的要求； ```   
有输出信息的步骤 ：```输出问题的答案。  ```

例1  求1×2×…×9×10 ，即10！  
算法思路：  
```
   N！=N ×（N-1）！  
   10！=10 ×9！=10 ×9 ×8！  
   =10 ×9 ×8 ×7！  
   = ······   
   =10 ×9 ×8×… ×2 × 1!  
   先计算1！、再计算2!=2*1!、再计算3!=3*2!,…
   以此类推，直到计算出10!=10*9!。 
``` 
使用变量p   
算法进行抽象:  
	```核心操作就是两数相乘p=i×p ，反复相乘10-1=9次，i初始值为2，p初始值为1，每相乘一次i的值加1。```  
根据上述分析，本题可利用循环结构求解：  
	```第1次循环用于求2！，第2次循环在第1次循环基础上求3！，… , 第9次循环在第8次循环基础上求10！```  


例1  求1×2×…×9×10 ，即10！
定义两个变量p和i，p代表阶乘结果,i代表本次循环要求的是i!；
                 
例1 源程序
```c
   # include <stdio.h>
   # include <stdlib.h> 
   main() 
   {
      int n, i, p;  //n：存储要求阶乘的数；p：存储求得的阶乘；
      printf("input n:\n");
      scanf("%d",&n);
      i=2;
      p=1;
      while (i <= n){	      
         p=i*p;
         i=i+1; 
      } 
      printf("%d!=%d", n, p);   
      system("pause");
      return 0;
   }
```
练习1：输入十个整数，求出最大值、最小值。  
算法思路：
```
采用迭代计算的方法  
    以求最大值为例，即：  
Max(N1)=N1  
Max(N2,N1)= N1   if  N2<N1  
			         = N2   if  N2>=N1  
Max(N3,N2,N1)= Max( N3, Max(N2,N1) )  
   ······  
Max(Nn , Nn-1 ,…,N2,N1) ＝  
			Max(Nn ,Max(Nn-1 ,…,N2,N1))  
```

源程序：输入十个整数，求出最大值、最小值
```c
   # include<stdio.h>
   # include<stdlib.h> 
   main() 
   {
      int i, n, count,max, min; /*i: 循环计数；n:读取的数；count:整数个 			数；max:当前最大值; min:当前最小值 */
                  
      printf(“input the count of the numbers:”); //输入整数个数
      scanf("%d",&count); 
      
      printf("input %d numbers:\n", count); 
      scanf("%d", &n);
      max=n;  // 将第一个数作为最大值和最小值
      min=n;
      i=2;  //代表接下去要读取的是第2个数
         
      
   while (i<=count){
         scanf(“%d”,&n);   //读取第i个数
         if (n > max)  //求最大数
            max = n;
         else if (n < min)  //求最小数
            min=n; 
         
         i=i+1;      
      }

      printf("max number is %d", max);
      printf("min number is %d", min);

      system("pause");
      return 0;
   }
```

例2  输入120个学生的学号和成绩，要求将他们之中成绩在60分以上者的学号和成绩打印出来。


```c
   #include<stdio.h> 
   main(){ 
         int no, total, count;  //no:学号；total:总学生数；count：计数 
      float score;  //成绩
      
      printf("how many int numbers do you want to input:\n");
      scanf("%d",&total);
      
      count=1;
      while(count<=total){//进入循环体之前的count代表下一个要读取的是第几个学生信息 
         printf("input no and score(no,score):\n");
         scanf("%d, %f", &no, &score);
         if (score>60)
               printf("no:%d\tscore:%f\n",no,score);
         count=count+1;    	 
      }				
         return 0；
   }
```
例3  一个大于或等于3的正整数，判断它是否为一个素数（质数） 。  
```
判断质数  
看n能否被2到（n-1）之间的各个整数整除：       
判断质数  
n：被判断的整数；i：除数；r：n/i的余数  
```
例4：整数分解 
``` 
输入一个不超过8位的正整数，要求把这个整数分解为单个数字，然后打印出每一个数字（每一个数字之间用两个空格分开）。例如用户输入了4231，程序打印结果为：  
    4  2  3  1。设计算法。
第1步：得到num最高位4并输出，num=231
第2步：得到num最高位2并输出，num=31
第3步：得到num最高位3并输出，num=1
第4步：得到num最高位1并输出，num=0
```
例5：判断回文数
```
设计算法，判断一个正整数是否是回文数。回文数是指正读和反读都一样的数。如121、1221就是回文数。

算法1：回文数的第i位和倒数第i位肯定相等
比较第1位和倒数第1位
比较第2位和倒数第2位
…

算法2：反着读，假设读得的数为reverseNum，判断num和reverseNum是否相等
以求a0a1a2a3的逆数为例，假设reverse实现逆着读
reverse(a3)=a3  
reverse(a2a3)=a3a2=a3*10 + a2= reverse(a3)*10+a2  
reverse(a1a2a3)=a3a2a1=a3a2*10 + a1  
                                   =reverse  (a2a3)*10+ a1
reverse(a0a1a2a3)=a3a2a1a0 =a3a2a1*10+a0
                                  =reverse(a1a2a3)*10+a0
```
判断回文数-算法2
```c
   #include<stdio.h>
   #include<stdlib.h>

   main()
   {
      int num;//存放输入的整数 
      int num1; /*循环中处理的数,每循环一次,右边少一位,假设num为1234,则 			num1初始值为1234,然后是123,然后是12......;*/
      int reverse;/*是用分解出来的数字组成的新数*/
      int m;/*m:存放每一个分解出来的数字;*/
      
      printf("请输入一个小于8位的正整数:"); //读取要判断的整数 
      scanf("%d",&num);   
      
      /*从右到左依次取出各个数字组装成一个新的整数保持到reverse中*/ 
      num1=num; 
      reverse=0;
      while(num1!=0){
         m=num1%10; /*取出num1的最低位*/
         reverse=reverse*10+m; /*将最低位组装到reverse中*/
         num1=num1/10; /*去掉num1的最低位*/
      }
                  
      if (num==reverse) 
      printf("%d 是回文数\n",num); 	
      else
      printf("%d 不是回文数\n",num); 	
      
      system("PAUSE");
      return 0; 
   }
```
# 4.2 算法的三种结构 
    三种控制结构(Bohra和Jacopini )描述算法
	 顺序结构、 选择结构、循环结构
                                 

 用步骤描述（如前所述）  
 用自然语言描述  
 用流程图描述   
 用N-S流程图描述  
 用伪码描述  
## 4.4  算法的描述－自然语言
```
文字冗长；  
语言的模糊性；  
不严格，不精确，易产生歧义；  
不方便描述分支和循环结构；
```  
## 4.4  算法的描述－流程图
```
 流程图的基本元素（ANSI规定） 
练习：将以上流程图改成用当型循环结构表示。
```
## 4.4  算法的描述－N-S流程图
传统流程图的弊端 

 对流程线的使用没有严格限制，阅读困难；
	 
 不能保证算法结构的单入单出特性；
	  
   占用篇幅较多 ；
  
流程图和N-S图画起来比较费事，适合于表示算法，而在算法设计中使用不是很理想。  
```
伪代码  
    用介于自然语言和程序设计语言之间的文字和符号来描述算法。
```
算法的核心操作是求两数之和，其中第一个操作数是前一次求得的和。如何求第二个操作数？  
算法1：n决定了第n项因子的值，即第二个操作数；因此每一次可根据当前n的值计算出第二个操作数。

请用N－S图描述出算法1。

```c
   # include<stdio.h>
   # include<stdlib.h>
   # include<math.h>
   main()
   {
      int i;
      float x; 
      double sum, p; 
      //p用于存放待加的那一项
      
      printf("input x:");
      scanf("%f",&x);
      
      /*变量初始化*/
      sum=0.0;
      i=1;
      p=x;
```
方法与技术(结构)  
问题：  
给定一群人(例如：在一个大操场上)，给定一个数值(例如: 175)，输出高度恰好等于该数值的人

方法：搜索

我们需要明确，用什么样的方式来实现“搜索”

更复杂的搜索结构  
“聪明”的搜索结构  
分治法( Divide-and-Conquer)  
1346343273756824*2389087095334098

可见，可以将2个16位数相乘的问题转换为4个8位数相乘的问题，继续对半拆分大整数，直到分成若干个1位数相乘，这个问题肯定可以解决。  
上面两个16位数相乘就可以分解为：  
```
   4个8位数相乘，                   4*4个4位数相乘，        
   4*4*4个2位数相乘，        4*4*4*4个1位数相乘 
   共256个1位乘法。
```
## 贪心算法(Greedy)
   4.5  算法实例  
猴子吃桃问题：有一堆桃子不知数目，猴子第一天吃掉一半，觉得不过瘾，又多吃了一只，第二天照此办理，吃掉剩下桃子的一半另加一个，天天如此，到第十天早上，猴子发现只剩一只桃子了，问这堆桃子原来有多少个？
```
分析：假设第一天早上吃前有桃子a1个,第二天早上吃前有桃子a2个，第三天早上吃前有桃子a3个，以此类推，则
a2＝a1－（a1/2+1）= a1/2-1
…
a9＝a8－（a8/2+1）= a8/2-1 
a10＝a9－（a9/2+1）= a9/2-1 = 1

即：
a9= 2 × ( a10+ 1 ) 
a8= 2 × ( a9+ 1 )
┇
a1= 2 × ( a2+ 1 )
也就是：ai＝2×(ai+1+1),  i=9, 8, 7, 6, ...,1 
现在已知a10值为1，可采用迭代法求得a1。
```
```c
   #include<stdio.h>
   #include<stdlib.h>
   main()
   {
      int day_count；//表示当前求解的是第几天
      int current_day_count; //表示某天的桃子数
      
      day_count = 9; // 表示第几天，初始化为9
      current_day_count = 1; //第10天吃前的桃子数是1 
      
      while(day_count >= 1){
      current_day_count = 2 * (current_day_count + 1);
      day_count = day_count - 1;
      }
      
      printf("桃子数是：%d", current_day_count );
      system("pause");
   }
```

第一天：1534个桃子  
第二天：766个桃子  
第三天：382个桃子  
第四天：190个桃子  
第五天：94个桃子  
第六天：46个桃子  
第七天：22个桃子  
第八天：10个桃子  
第九天：4个桃子  
第十天：1个桃子  

一个皮球从100m高处落下，每次落地后反弹到原来高度的一半。编写程序，求20次反弹时弹起的高度。
```c
   #include<stdio.h>
   #include<stdlib.h>
   #define TIMES 20 
   main()
   {
      int times; //记录是第几次弹起 
      double height; //记录小球弹起时的高度 
      
      height=10000.0;  /*height的单位是cm*/
      times=1;/*第一次循环求第1次弹起高度 */
      
      while(times<=TIMES){
         height=height/2;/*除以2后的height表示第times次弹起的高度*/ 
         times=times+1;
      } 
      
      printf("第%d次小球弹起的高度是%f厘米",TIMES,height);
      system("pause");
      return 0; 
   } 
```
每个大于1的正整数都能表示为素数的乘积。这个因数分解是唯一的，被称为素数分解（prime factorization）。  
例如，数字60=2*2*3*5, 799=17 *47, 其中每一个约数都是素数。注意:同一个素数在因数分解中可以出现多次。 

设计一个算法显示数n的素数分解 。
```
 问题分析： 60=2*2*3*5
 f(p)=n*f(p/n), n是p的最小质数因子
 对p进行素数分解，可以转化为两步：
   1：找到p的最小质数因子n；
   2：对p/n继续进行素数分解。
f(p)=n*f(p/n), n从2开始试探，逐渐变大（加1）。若试探过程中发现p能被n整除，则n肯定是素数。
原因分析：根据题意，任何合数均能分解为若干个素数的乘积。假设n为6且p除以n余数为0。由于6＝2*3, 因此，在分解出6之前早就已经分解得到2*3了，所以 n不可能为6。
```

**艾伦.图灵和图灵机**  
英国数学家， 1912年生于英国伦敦， 1931年考入剑桥皇家学院，22岁当选皇家学院的研究员。

思考数学函数的“可计算性”问题(即什么样的问题是可计算的) ：数学上的一些函数，是不是只要给足够时间来进行演算，通过有限次机械步骤就能求得解答？ 

1936年，图灵发表论文《论可计算数在判定问题中的应用》，给“可计算性” 下了一个严格的数学定义，并提出著名的“图灵机”(Turing Machine)的设想。   
艾伦.图灵和图灵机  
图灵机的组成：  
一个无限长的纸带  
一个读写头（中间那个大盒子）  
内部状态（盒子上的方块，比如A,B,E,H），  
一个程序，用于对这个盒子进行控制。  
工作原理：根据程序的命令以及它的内部状态进行磁带的读写、移动 ，直至得到最后的结果。  

每个图灵机有一个状态集Q，其中包括一个开始状态和一个结束状态；  
图灵机包含一个符号集S。  
图灵机工作：首先从开始状态启动，每次动作都由控制器根据图灵机当前状态和读写头所对准的符号决定下一步的操作。操作包含：   
1. 把某个符号写入读写头当前对准的小格内，取代原来那个符号；  
2. 读写头向左移动一格，向右移动一格，或者不移动；
3. 根据控制器的命令用某个状态取代当前状态，使图灵机进入下一个新状态。

图灵机举例-逻辑求反  
字母表A={0,1,b}，b表示空格  状态集Q={q1,q2,q3},  
其中q1是初始状态，q3是终止状态. 控制器命令如下：  
q1  0  1  R q1 (说明：q1状态下读取0，则将1写入读写头对准的位置，读写头右移一格，图灵机状态转换为q1)  
q1  1  0 R q1  
q1  b  b R q2  
q2  b  b L q3  
q2  0  0 H q1  
q2  1  1 H q1  
其中，L，R，H分别代表读写头左移一格，右移一格，保持不动三个基本操作  
若输入是：1100b0011, 读写头对准第一个1，初始状态为q1  
实现求反的功能。

图灵机举例-减法  
求m-n 可以在纸带上初始设置 m个“0”，之后“1”，然后再设置 n个“0” 。  
计算结果：带上留下m-n个0，即结果为m-n。

自动机模型  
为了描述一个有限自动机的工作状况，可采用状态转换图。状态转换图是一个有向图，图中的每个节点表示一种状态，一条边（或弧）表示一个转换关系。

自动机计算模型  
例 设计交通车辆观测统计算法。   
问题描述：在一个路口设置一个探测器，通过通信线路连接到后台的计算机。路口每通过一辆汽车，探测器向计算机发出一个车辆信号‘1’，探测器每隔1秒钟向计算机发出一个时钟信号‘0’，观测结束向计算机发出结束信号‘＃’。 

要求在计算机上设计一个程序，能够接收探测器发出的信号，统计出观测的时长、在观测时长内通过的车辆总数、以及两辆车之间最大的时间间隔。 
```  
程序设计实例研究
审题：
程序读入由‘0’或者‘1’组成的字符串，这个字符串可以映射为有限自动机模型中的字符输入带。
我们的任务就是设计控制器程序逐字符地读取输入带，进行处理并引起控制器的状态改变，最终产生输出，因此这个问题的求解就抽象为一个有限自动机。
交通灯观测实例研究-解法1
1、确定输入集T＝{‘1’，‘0’，‘#’} 
2、绘制状态迁移图
3、确定转换函数
当前状态是q0 (state==q0)：
读入'1'：vehicles++; state=q1
读入'0'：seconds++;  state=q2
读入EOF： state=q3
当前状态是q1 (state==q1，说明前一个字符是'1')：
读入'1'(11)：vehicles++; 
读入'0'(10)：interval=1;seconds++; state=q2
读入EOF： state=q3

当前状态是q2 (state==q2，说明前一个字符是'0')：
读入’1’(01)：if(vehicles>0)    处理最大时间间隔
			          vehicles++; state=q1
读入'0'(00)：seconds++; 
			       if(vehicles>0)  interval++;
读入EOF： state=q3

终止状态集F={q3}
```
交通灯观测实例研究-解法2
```
1、确定输入集T＝{‘1’，‘0’，‘#’} 
2、对输入集中的‘1’和‘0’分类，确定状态:
‘0’
不是两个1之间的‘0’：进入状态  q1
是两个1之间的‘0’ ：进入状态  q2
‘1’
不是需要处理时间间隔的‘1’：进入状态 q3
是需要处理时间间隔的‘1’：进入状态 q4
‘#’
进入结束状态   q5

交通灯观测实例研究-解法2
3、绘制状态迁移图

交通灯观测实例研究-解法2
4、确定状态转移函数
当前状态是q0
读入‘1’：vehicles++; state=q3
读入‘0’：seconds++; state=q1
读入‘#’ ： state=q5
当前状态是q1
读入‘1’：vehicles++; state=q3
读入‘0’：seconds++; 
读入‘#’ ： state=q5
交通灯观测实例研究-解法2
4、确定状态转移函数（续）
当前状态是q3
读入‘1’：vehicles++; 
读入‘0’：seconds++; interval++;state=q2
读入‘#’ ： state=q5
当前状态是q2
读入‘1’：vehicles++；				  	   if(interval>longest)		         		    	  longest=interval;
                    interval=0; state=q4 ;
读入‘0’：seconds++; interval++;
读入‘#’ ： state=q5

交通灯观测实例研究-解法2
4、确定状态转移函数（续）
当前状态是q4
读入‘1’：vehicles++; state=q3
读入‘0’： seconds++; interval=1; state=q2
读入‘#’ ： state=q5
```

练习：将一个由数字字符组成的字符串转换为整数或者小数并输出。如：
	输入:134.567#
    输出:134.567
```c
   # include<stdio.h>
   # include<stdlib.h>
   main()
   {
      char ch;
      int num; //存放小数点前面的字符转换后得到的整数 
      float fnum; //存放小数点后面的字符转换后得到的浮点数 
      int n; //存放字符对应的数字 
      int p; // 存放小数点后面的字符转换后得到的数字对应的基数1/p。小数点后第一位数的基数是1/10 
      int flag;//用于表示输入的字符中是否有小数点。若有，则flag值为1；否则为0 

      num = 0;
      fnum = 0;
      p = 10;
      flag = 0;
      printf("please input the string:"); 

   scanf("%c",&ch);
   while( ch != '#'){
         if (ch=='.')
            flag = 1;  // flag为1，表示输入了小数点
         else{ //处理小数点之前的字符
            n = ch - '0';
            if (flag == 0) {//若输入的是小数点之前的数 
               num = num * 10 + n;
            } 
            else {//处理小数点之后的字符
               fnum = fnum + (float)n / p; //必须进行强制类型转换，否则n/p结果为0   
               p = p * 10;
            } 
         }
         scanf("%c", &ch);
      }

   if (flag == 0)
         printf("the result is:%d\n",num);
      else
         printf("the result is:%f\n",num+fnum);

      system("pause");
      return 0;
   }
```
```c
# include<stdio.h>
main()
{
   char ch;
   int num;
   float fnum; 
   int n,p,flag=0;
   
   printf("please input the string:"); 
   //处理整数部分 
   num = 0;
   scanf("%c",&ch);
   while(ch != '.' && ch != '#'){
      n = ch - '0';
      num = num * 10 + n;
      scanf("%c",&ch);
   }

 if (ch=='.') {
       //处理小数部分  
       p = 10;    flag = 1;  //flag为1表示有小数部分
       scanf("%c",&ch);
       while(ch != '#'){
          n = ch - '0';
          fnum = fnum + (float)n / p; //必须进行强制类型转换，否则n/p结果为0 
          scanf("%c",&ch);
          p = p * 10;
       }
   }
    if (flag == 0)
         printf("the result is:%d\n",num);
   else
         printf("the result is:%f\n",num+fnum);   
   return 0;
}
```





穷举法解题  
    解题思路：对可能是解的众多候选解按某种顺序进行逐一枚举和检验，从中找出那些符合要求的候选解作为问题的解。  
如：打印所有除以11后所得商正好是它的各个数字平方和的三位数 。  
穷举法解题  
    例1：编写程序，求出所有5、6、7组成的、且各位数字互不相同的三位数。
   
穷举法解题  
算法优化：  
穷举法解题  
例2：5位跳水高手将参加10m高台跳水决赛，好事者让5人据实力预测比赛结果。  
	A选手说：B第二，我第三；  
	B选手说：我第二，E第四；  
	C选手说：我第一，D第二；  
	D选手说：C最后，我第三；  
	E选手说：我第四，A第一。  
	决赛成绩公布后，每位选手的预测都说对了一半，即一对一错。请设计算法求出比赛的实际名次。
```
穷举法解题
明确组合情况：
A可以是第一、第二、第三、第四或者第五
B可以是第一、第二、第三、第四或者第五
C可以是第一、第二、第三、第四或者第五
D可以是第一、第二、第三、第四或者第五
E可以是第一、第二、第三、第四或者第五
检查是否满足约束条件：
A说：B第二，A第三；
B说：B第二，E第四；
C说：C第一，D第二；
D说：C第五，D第三；
E说：E第四，A第一。
而且都只说对了一半。

检测条件：
比赛名次-1
```
```c
   int main(){
      int a,b,c,d,e;   //用于记录A～E分别的名次
      int countA,countB,countC,countD,countE;//用于记录A～E分别说对的话个数 
      for(a=1;a<=5;a++)//a～e分别代表A～E选手的名次 
         for(b=1;b<=5;b++)
            if (a!=b)
                     for(c=1;c<=5;c++)	
               if (c!=a &&c!=b)
                  for(d=1;d<=5;d++)		 		
                        if (d!=a && d!=b && d!=c)
                           for(e=1;e<=5;e++)	
                                    if (e!=a && e!=b && e!=c && e!=d)
                                    if ((b==2 && a!=3 || b!=2 && a==3) &&
                                                      (b==2 && e!=4 || b!=2 && e==4) &&
                                                      (c==1 && d!=2 || c!=1 && d==2) &&
                                                      (c==5 && d!=3 || c!=5 && d==3) &&
                                                      (e==4 && a!=1 || e!=4 && a==1)) { 
                           printf("比赛名次是:\n"); 
                           printf("A:第%d名\nB:第%d名\nC:第%d名\nD:第%d名\nE:第%d名\n",a,b,c,d,e);
                                                } //if
   } 
   比赛名次-2
   ...
   if (e!=a && e!=b && e!=c && e!=d) { 
      countA=(b==2)+(a==3);
         countB=(b==2)+(e==4);
      countC=(c==1)+(d==2);
         countD=(c==5)+(d==3);
         countE=(e==4)+(a==1);
         if (countA==1 && countB==1 && countC==1 && countD==1 && countE==1)
      {     printf("比赛名次是:\n"); 
            printf("A:第%d名\nB:第%d名\nC:第%d名\nD:第%d名\nE:第%d名\n",a,b,c,d,e); 
      } //if
   }  //if           
   } 
```


百鸡问题：用100元买100只鸡，大公鸡5元1只，母鸡3元1只，小鸡1元3只。问各能买多少只？

合伙捕鱼：A 、 B 、 C 、 D 、 E 五人夜间合伙捕鱼，凌晨时都疲倦不堪，各自在河边的树丛中找地方睡着了。日上三竿， A 第一个醒来，他将鱼分作五份，把多余的一条扔回河中，拿自己的一份回家去了。 B 第二个醒来，也将鱼分作五份，扔掉多余的一条，拿走自己的一份，接着 C 、 D 、 E 依次醒来，也都按同样的办法分鱼，问五人至少合伙捕了多少条鱼？试编程序算出。 
```
问题分析：
设原先鱼的总数是x条 ，设A、B、C、D、E拿之前剩下的鱼数量分别为A、B、C、D、E，则 
    A=x;
    B=（A-1）*4/5;
    C=（B-1）*4/5;
    D=（C-1）*4/5;
    E=（D-1）*4/5;
E可以是 6、11、16……（以5递增）  ( 注：(E-1)/5 >=1 )
若E已知，则由E可依次推出D、C、B、A。
此外，D、C、B、A要满足以下约束：
   (D-1) mod 5==0         能被5整除
   (C-1) mod 5==0
   (B-1) mod 5==0
   (A-1) mod 5==0
```
```c
   #include<stdio.h>
   int main(){
      int fish;  //e拿之前剩下的鱼数量
      int newfish;//迭代变量，记录鱼的数量
      int finish,isOK; // 结束标志 
      int i;//for循环控制变量 
      
      finish=0;
      for (fish=6;finish==0;fish+=5) {
      //E递增且满足(E-1）%5==0.  

         newfish = fish; 
         isOK = 1;
      for (i=1;i<=4 && isOK==1;i++){
            //四次循环，依次求得D,B,C,A 
            newfish = newfish*5/4+1;
            if ((newfish-1)%5!=0) 
            //如果不满足(fish-1)%5==0  
                  isOK = 0;
         } //end for(i)     
         
         if (isOK==1)
            finish=1;
      }//end for(fish) 
      printf("至少是%d条鱼",newfish); 
      return 0;
   }//end main()
```