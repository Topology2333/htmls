---
title: 7-计导导论
author: Topology2333
date: '2022-12-06'
tags: computer science
---
# 这一篇转载 7
```

```
### 提纲
### 递归的概念
### 递归过程
### 递归程序设计
```

```
# 1.递归的概念
原始递归函数在可计算性理论中占有重要地位，是一种算法思想和计算模型。
基于原始递归函数的递归算法是算法设计的有力工具，对于拓展编程思路非常有用。
进行递归算法设计的前提是要建立起递归概念，我们先从一个最简单的例子导入。

例：编写一个函数fac，计算阶乘n!
按过去的迭代算法，该函数可以写成：
```c
int fac(int n)
{
     int i, p;
     p = 1;
     for(i = 2; i <= n; i++)
           p = p * i;
     return p;
} 
```
现在换一个角度考虑，n！不仅是1×2×3×…×n,
还可以定义成：		

- 递归的定义：
 从程序书写来看，在定义一个函数时，若在函数的功能实现部分又出现对它本身的调用，则称该函数是递归的或递归定义的。  
 从函数动态运行来看，当调用一个函数A时，在进入函数A且还没有退出（返回）之前，又再一次调用A，则称为函数A的递归调用。  

递归可以分为直接递归和间接递归两种。
1. 直接递归：函数体里面发生对自己的调用；
2. 间接递归：函数A调用函数B，而函数B又直接或间接地调用函数A。

不用担心函数A内部又调用函数A，会使得调用无休无止，肯定存在某个条件，当该条件成立的时候，函数A将不会再调用自身。
   
例如，求n！时，该结束条件是 if(n == 0) 
```c
   int f(int n)
   {
      if (n == 0) 
         return 1;
      else
         return n * f(n-1);
   }
```
# 2.递归过程

请思考：
发出f(2)调用时，将2赋值给形参n。然后发出f(1)调用，将1赋值给形参n。接着发出f(0)调用，将0赋值给形参n。后来赋给形参n的值会不会覆盖原来赋给n的值（如值1覆盖原来的值2）？为什么？  
    不会，每一次函数调用会在栈顶分配新的活动记录。  

对递归函数的每一次调用结束返回时，为何能回到调用前的程序运行状态？  
    当f(1)调用结束时，位于栈顶的f(1)的活动记录将出栈，位于栈顶的将是f(2)函数的活动记录。

- 递推阶段：
递推阶段是个不断简化问题的阶段：把对较复杂问题（规模为n）的求解转化为比原问题简单一些的问题（规模小于n）的求解 。例如对f (6)的求解转化为f(5)的求解， 对f(5)的求解转化为f(4)的求解…直到转化为对f(0)的求解。
当递推到最简单的不用再简化的问题时，递推终止。如f函数中，n==0的情况。
- 回归阶段：
在回归阶段，当获得最简单情况的解后，逐级返回，依次得到稍复杂问题的解 。如在得到f(1)的解后，又依次得到f(2)、f(3)…直到f(6)的值。
思考：递归与迭代的比较(以求阶乘为例)。
迭代:从已知的初始条件出发(自底向上)，逐次去求所需要的阶乘值，这相当于从菜心“推到”（通过循环）最外层的菜叶。
				f(0) = 1
				f (1) = 1*f (0) = 1
				f (2) = 2*f (1) = 2
递归：先从最外层的菜叶“递推”到菜心(自顶向下,递归函数调用)，再从菜心“回归”到最外面的菜叶（递归函数返回，带值返回）。

递归算法的出发点不放在初始条件上，而放在求解的目标上，是从所求的未知项出发逐次调用本身的求解过程，直到递归的边界（即初始条件）。   
就求阶乘而言，读者会认为递归算法可能是多余的，费力而不讨好。但许多实际问题，从初始条件出发不可能或不容易找到显而易见的迭代关系，这时从求解目标出发的递归算法就表现出了明显的优越性。  
下面我们将会看到，递归算法比较符合人的思维方式，逻辑性强，可将问题描述得简单扼要，具有良好的可读性，许多看来相当复杂，或难以下手的问题，如果能够使用递归算法就会使问题变得易于处理。

# 3.递归程序设计
什么样的问题可以用递归解决？  
回顾“自顶向下，逐步细化”的程序设计思想。  
如果解决问题的方法是把该问题分解成小的子问题，并且这些小的子问题可以用同样的算法解决，这样不断分解，直到子问题比较简单、可以直接解决时分解过程即终止，那么就可以用递归。(分治策略)  
递归的思想就是先将一个问题转化为与原问题性质相同、但规模小一级的子问题，然后再重复这样的转化，直到问题的规模减小到我们很容易解决为止。  

递归程序设计举例

>练习1.求浮点数x的n次幂(n≧0)。函数递归定义:

>练习2. 设计递归函数求任意正整数的位数。num=1234
			
```
递归思路1：将除最高位之外的数先逆置。

例如： reverse (1234)=reverse(234）×10 + 1 

递归设计思路1：
   num=1234

   reverse(1234,4)＝1+ reverse(234,3)*10
    
   reverse(234,3)=2+reverse(34,2)*10
    
   reverse(34,2)=3+reverse(4,1)*10                               
 
   reverse(4,1)=4
```			
```c
int reverse(int num,int len)
{
    int restNum, highBit;

    if (len == 1)          //如果num是个位数则递归结束 
        return num;
    else{
  highBit = num / power(10, len-1);//得到最高位 
  restNum = num % power(10, len-1); //得到剩余位
  //递归调用，并形成逆置数
  return highBit + reverse(restNum, len-1)*10; 
}
}
```
>练习3. 求任意正整数的逆置数。  
```
递归思路2：将除最低位之外的数先逆置。
例如：reverse(1234)=4*1000+reverse(123)

递归设计思路2： num=1234
    reverse(1234,4)＝4*1000+ reverse(123,3)
    
    reverse(123,3)=3*100+reverse(12,2)
    
    reverse(12,2)=2*10+reverse(1,1)                               
   
    reverse(1)=1
```
```c
int reverse(int num,int len)
{
    int restNum;
    int lowBit;
    
    if (len==1)   //余数为0，作为递归的结束条件 
       return num;
    else{
       lowBit=num%10;//保留最低位 
       restNum=num/10;//得到除去最低位后的余数 
       //递归调用，并形成逆置数 
       return lowBit*power(10,len-1) + reverse(restNum,len-1); 
    }
}
```
>练习4. 输入n个整数，求最大数。 
```
       15  30  34  10  89 
设函数findMax(n)为读取n个数，求最大值
  函数Maximum(x,y)为求两个数x和y的最大值
则findMax(n)递归定义：
findMax(1)=N1                           当n=1
findMax(n)=Maximum(findMax(n-1),Nn)     当n>1
求前n(n>1)个数的最大值，分解为3步：
	第1步：读取前n-1个数，求出最大值max；
	第2步：读取第n个数num；
	第3步：返回num和max之间的最大值
```


```c
// 读取n个数，求最大值
int findMax(int n) 
{
 	 int max;  //记录前n-1个数中的最大值 
 	 int num;  //读取的第n个值 
	 
	 if(n==1){  //求前1个数中的最大值
	        scanf("%d",&num);
	        return num;
	 }
	 else{  
	     max=findMax(n-1); //第1步：读取前n-1个数，求出最大值max ；
	     scanf("%d",&num); //第2步：读取第n个数num；	 
	     return num>max?num:max;  /*第3步：计算并返回num和					               max之间的最大值*/
       }	    
}

findMax(4)   
   findMax(3)，

findMax(3)
   findMax(2)，

findMax(2)
  findMax(1)

findMax(1)   
      读取第1个数15
```

> 练习4. 输入n个整数，求最大数。
```
递归设计思路2：15  30  34  10  89 
设函数findMax(n)为读取n个数，求最大值；
  函数Maximum(x,y)为求两个数x和y的最大值；
则findMax(n)递归定义：
findMax(1)=N1                                  当n=1
findMax(n)=Maximum(N1,findMax(n-1)) 当n>1
求前n(n>1)个数的最大值，分解为3步：
    第1步：读入第1个数num 
    第2步：调用递归函数，读取后续n-1个数，求最大数max
    第3步：返回num和max中的最大值。
```
```c
int findMax (int n)  // 读取n个数，求最大值
{ 
	int num, max;
	 
	if (n==1){
          scanf("%d",&num);  /*第1步：读入一个数num */
	     return num;  /*若是最后一个数，则将其本身作为最大值并返回*/ 
	} 
	else{
         scanf("%d", &num);  /*第1步：读入一个数num */
 	   max=findMax (n-1);    /*第2步：调用递归函数读取并求出后续n-1个 			                      数的最大值max*/ 
	   return num>max?num:max; /*第3步：返回num和max中的最大值*/ 
     } 
}

findMax(4)
     读15， 调用findMax(3)

findMax(3) 
    读30，调用findMax(2) 

findMax(2)
   读34，调用findMax(1)

findMax(1)
   读10

```

>例3：用函数fib求斐波那契数列的第n项。
```
斐波那契数列为：0、1、1、2、3、…… 。函数fib定义如下：
```
```c
# include <stdio.h> 
long fib (long);   
main()
{
     printf(“%ld”, fib(3));
     system(“pause”);
     return 0;
}
long fib (long n)
{
     if (n==1 || n==2) 
         return n-1;
     else
         return fib(n-2)+fib(n-1);
}
```

每求一项数，需要递归调用2次该函数；计算斐波那契数列第30项的递归调用次数是**2的30次方**（大约10亿次！）
可见递归的思想特别符合人们的思维习惯，便于问题解决和编程实现。但递归的程序设计方法**比较占用系统资源，效率也较低**。

课下请改写fib函数，使用迭代算法实现
	long fib(long n), 计算斐波那契数列第n项。

>例4、汉诺塔问题
	
```
在A柱上有3只盘子，从小到大分别为1号，2号，3号
第(1)步将1号盘和2号盘视为一个整体；先将二者作为整体从A移至B，给3号盘创造能够一次移至C的机会。这一步记为	move( 2, A, C, B)
    意思是将上面的2只盘子作为整体从A借助C移至B。
第(2)步将3号盘从A移至C，一次到位。记为
			            move 3 from A to C
第(3)步处于B上的作为一个整体的2只盘子，再移至C。这一步记为    	move( 2, B, A, C)
意思是将2只盘子作为整体从B借助A移至C。
```

```
从题目约束条件看，大盘上可以摞小盘，相反则不允许。在将1号和2号盘当整体从A移至B的过程中move(2, A, C, B)实际上是分解为以下三步
第1步：move 1 from A to C;
第2步：move 2 from A to B;
第3步：move 1 from C to B;

同样，3号盘一旦到了C，就要考虑如何实现将1号和2号盘当整体从B移至C的过程了。实际上move(2, B, A, C)也要分解为三步：
第1步：move 1 from B to A;
第2步：move 2 from B to C;
第3步：move 1 from A to C;

同理，将n个圆盘从A柱移到C柱move(n, A, B, C) 可分解为3步：
第1步.将A柱上从上往下数的（n－1）个圆盘移到B柱上，通过C柱为辅助。这是一个（n－1）个圆盘的问题：move(n-1,A,C,B)；
第2步. 将A柱上最后一个圆盘，直接移到C柱上；
第3步. 再将B柱上的（n－1）个圆盘移到C柱上，中间以A柱为辅助。这又是一个（n－1）个圆盘的问题:move(n-1,B,A,C)；



这显然是递归定义的，将问题分解成同类小问题。当解move(n-1, A, C, B)时，又可将其分解为3步：
第1步：将A柱上的n-2只盘子作为一个整体从A经B到C，move(n-2, A, B, C)；

第2步：第n-1号盘子从A直接移至B；
第3步：再将C柱上的n-2只盘子作为一个整体从C经A移至B，move(n-2, C, A, B)；


移动n个盘子的问题被简化成移动n－1个盘子的问题；
移动n-1个盘子的问题又被简化成移动n-2个盘子问题 ……
该过程反复进行，直到只剩下1个盘子时再将其移动。移动1个盘子的简单操作就是终止条件。
```
```c
void move(int n, int from, int med, int to)
{
     if (n==1)
            printf("%d-->%d \n", from, to);
     else{
             move(n-1, from, to, med);
     	 printf("%d-->%d \n", from, to);
     	 move(n-1, med, from, to);
     }
}
#include<stdio.h>
void move(int n,int a,int b,int c);
main()
{
    int num；
    printf("the number of plate is:");
    scanf("%d",&num);
    move(num, 1, 2, 3);
    system(“pause”);
    return 0;
 }
```
>>移动3个盘子的递归调用过程见《计算机导论与程序设计基础》261页

注意分析：  
为何调用能正确返回  
为何每次调用访问的是正确的函数运行空间  
移动三个盘子的运行结果  
the number of plate is:3  
1-->3  
1-->2  
3-->2  
1-->3  
2-->1  
2-->3  
1-->3  

>练习5.  输入任意个整数，以-1结束，求最大数。

递归设计思路： 
  第一步：读入一个数num ;
  第二步：调用递归函数求出剩下要读入的数的	        最大值max; 
  第三步：求出num和max中的最大值并返回，   
                  此值即为输入的所有数的最大值。
```c
int findMax () 
{
    int num, max;
    scanf ("%d", &num);   //读入一个数num  
    if (num = = -1)
       return ?   ; //此处怎么写？
     else {
	   max = findMax();  //求出剩下要读入的数的最大值max
	   return(num>max?num:max); //返回num和max中的最大值
      }	
}
findMax()
[20,-15,-1]
[20,-15,-1]
```
解决方法：将本次递归调用读入的数作为参数传到下一次递归调用中
函数接口：int findMax(int preNum)
函数功能：求preNum和后续读入的数的最大值


```c
int findMax (int preNum)  //参数为上一层读入的数 
{
    int max, curr_num; //当前最大值，当前层读入的数 
    scanf("%d", & curr_num);
    if (curr_num ==-1)     //如果是结束标志 
         return  preNum ；
   else {
       //递归调用，得到后续数列中最大值 
        max=findMax (curr_num);
       //比较确定当前的最大值 
        return (preNum > max? preNum :max); 
    }
}
```

总结
1. 递归的定义：  
递归（Recursion），在数学与计算机科学中，是指在函数定义中使用函数自身的方法。
英文的Recursion从词源上分析只是“re-  (again)” + “curs- （come, happen）” 也就是重复发生，再次重现的意思。 
而对应的中文翻译表达了：“递＋归”。这正是递归的核心思想。
2. 递归算法设计步骤:  
设计问题最简单时候的终止条件和对应操作，即递归边界条件。
对所求解的问题，考虑如何拆分成与原问题性质相同但规模小一级的子问题，即书写递归定义。
根据以上两个步骤，正确地设计递归函数的参数。

3. 用递归定义描述曾经的算法：
    ```
    例1、求n个数最大值的数学方法（递归）
    Max(N1)=N1     		              (n=1，边界条件)
    Max(Nn , Nn-1 ,…,N2,N1) 
        ＝Max(Nn ,Max(Nn-1 ,…,N2,N1))   (n>1，递归定义)
    例2、求n个数的和的数学方法（递归）
        sum(N1)=N1   				(n=1，边界条件)
        sum(Nn , Nn-1 ,…,N2,N1)
        ＝sum(Nn ,sum(Nn-1 ,…,N2,N1))	(n>1，递归定义)
    ```


